name: Release

on:
  push:
    tags:
      - 'v*'  # например, v1.0.0
  schedule:
    - cron: '30 1 * * *'  # по расписанию, если CD_MODE позволяет
  workflow_dispatch:
    inputs:
      ref:
        description: 'ref/branch/tag для выпуска (по умолчанию текущая ветка)'
        required: false
        default: ''
      require-ci-success:
        description: 'Проверить, что CI (ci.yml) зелёный для выбранного ref'
        required: false
        default: 'true'

jobs:
  build-packages:
    name: "Release: build packages (Linux / macOS / Windows)"
    if: |
      (
        (vars.CD_MODE == '' || vars.CD_MODE == 'auto')
        && (github.event_name == 'push' || github.event_name == 'workflow_dispatch')
      ) || (
        vars.CD_MODE == 'scheduled'
        && (github.event_name == 'schedule' || github.event_name == 'workflow_dispatch')
      ) || (
        vars.CD_MODE == 'manual'
        && github.event_name == 'workflow_dispatch'
      )
    runs-on: ${{ matrix.os }}

    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]

    defaults:
      run:
        shell: bash

    steps:
      - name: Ensure CI passed for ref (workflow_dispatch)
        if: github.event_name == 'workflow_dispatch' && inputs.require-ci-success == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const refInput = core.getInput('ref');
            const ref = refInput && refInput.trim().length > 0 ? refInput.trim() : context.ref;
            const branch = ref.startsWith('refs/heads/') ? ref.replace('refs/heads/', '') : ref;

            core.info(`Checking CI status for ref: ${ref}`);
            const runs = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'ci.yml',
              branch,
              per_page: 1,
              status: 'success',
            });

            if (!runs.data.workflow_runs.length) {
              throw new Error(`Не найден успешный прогон ci.yml для ${ref}. Запустите CI и повторите.`);
            }

      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_dispatch' && inputs.ref != '' && inputs.ref || github.ref }}
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Meson env
        uses: ./.github/actions/setup-meson-env

      - name: Setup MSVC (Windows)
        if: runner.os == 'Windows'
        uses: ilammy/msvc-dev-cmd@v1

      - name: Configure (release)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          meson setup builddir \
            --buildtype=release

      - name: Configure (release, Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          meson setup builddir --buildtype=release

      - name: Build
        if: runner.os != 'Windows'
        shell: bash
        run: meson compile -C builddir

      - name: Build (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: meson compile -C builddir

      - name: Run tests
        if: runner.os != 'Windows'
        shell: bash
        run: meson test -C builddir --print-errorlogs

      - name: Run tests (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: meson test -C builddir --print-errorlogs

      - name: Install into staging directory
        if: runner.os != 'Windows'
        shell: bash
        run: |
          meson install -C builddir --destdir=install-root

      - name: Install into staging directory (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          meson install -C builddir --destdir=install-root

      - name: Create package
        if: runner.os != 'Windows'
        shell: bash
        run: |
          set -euo pipefail
          OS_NAME=${{ runner.os }}
          TAG_NAME=${{ github.ref_name }}
          PKG_BASE=awesome_calc-${TAG_NAME}-${OS_NAME}

          PKG_NAME="${PKG_BASE}.tar.gz"
          tar czf "${PKG_NAME}" -C install-root .
          echo "PKG_NAME=${PKG_NAME}" >> "$GITHUB_ENV"

      - name: Create package (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $OS_NAME = "${{ runner.os }}"
          $TAG_NAME = "${{ github.ref_name }}"
          $PKG_BASE = "awesome_calc-$TAG_NAME-$OS_NAME"

          python - <<'PY' "$env:PKG_BASE"
            import shutil
            import sys
            from pathlib import Path

            base = sys.argv[1]
            shutil.make_archive(base, 'zip', root_dir=Path('install-root'))
          PY
          
          $env:PKG_NAME = "$PKG_BASE.zip"
          echo "PKG_NAME=$env:PKG_NAME" >> "$env:GITHUB_ENV"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.PKG_NAME }}
          path: ${{ env.PKG_NAME }}

  github-release:
    name: "Release: publish GitHub Release"
    runs-on: ubuntu-latest
    needs: build-packages
    if: needs.build-packages.result == 'success'

    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: dist

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          files: dist/**/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
